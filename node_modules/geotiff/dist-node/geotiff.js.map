{"version":3,"sources":["globals.js","rgb.js","predictor.js","compression/basedecoder.js","compression/raw.js","compression/lzw.js","compression/jpeg.js","compression/deflate.js","compression/packbits.js","compression/index.js","resample.js","geotiffimage.js","dataview64.js","dataslice.js","pool.js","source/httputils.js","source/basesource.js","utils.js","source/blockedsource.js","source/client/base.js","source/client/fetch.js","source/client/xhr.js","source/client/http.js","source/remote.js","source/arraybuffer.js","source/filereader.js","source/file.js","geotiffwriter.js","logging.js","geotiff.js"],"names":["fieldTagNames","fieldTags","key","hasOwnProperty","parseInt","fieldTagTypes","arrayFields","BitsPerSample","ExtraSamples","SampleFormat","StripByteCounts","StripOffsets","StripRowCounts","TileByteCounts","TileOffsets","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","WhiteIsZero","BlackIsZero","RGB","Palette","TransparencyMask","CMYK","YCbCr","CIELab","ICCLab","ExtraSamplesValues","Unspecified","Assocalpha","Unassalpha","geoKeyNames","geoKeys","fromWhiteIsZero","raster","max","width","height","rgbRaster","Uint8Array","value","i","j","length","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","c","m","y","k","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","r","g","b","x","z","Math","min","decodeRowAcc","row","stride","offset","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","applyPredictor","block","predictor","bitsPerSample","planarConfiguration","Error","byteLength","Uint16Array","Uint32Array","BaseDecoder","decode","fileDirectory","buffer","decoded","decodeBlock","Predictor","isTiled","tileWidth","TileWidth","ImageWidth","tileHeight","TileLength","RowsPerStrip","ImageLength","PlanarConfiguration","RawDecoder","MIN_BITS","CLEAR_CODE","EOI_CODE","MAX_BYTELENGTH","getByte","array","position","d","a","floor","de","ef","fg","dg","console","warn","chunk1","chunks","chunk2","hi","appendReversed","dest","source","push","decompress","input","dictionaryIndex","dictionaryChar","dictionaryLength","initDictionary","getNext","byte","addToDictionary","getDictionaryReversed","n","rev","result","code","oldCode","val","oldVal","undefined","LZWDecoder","dctZigZag","Int32Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","buildHuffmanTable","codeLengths","values","children","p","q","pop","decodeScan","data","initialOffset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","mcusPerLine","progressive","startOffset","bitsData","bitsCount","readBit","nextByte","toString","decodeHuffman","tree","node","bit","receive","initialLength","receiveAndExtend","eobrun","successiveACState","successiveACNextValue","decodeMcu","component","decodeFunction","mcu","col","mcuRow","mcuCol","blockRow","v","blockCol","h","blocks","blocksPerLine","componentsLength","decodeFn","decodeDCFirst","zz","t","huffmanTableDC","diff","pred","decodeDCSuccessive","decodeACFirst","e","rs","huffmanTableAC","s","decodeACSuccessive","direction","decodeBaseline","marker","mcuExpected","blocksPerColumn","mcusPerColumn","usedResetInterval","buildComponentData","lines","samplesPerLine","R","quantizeAndInverse","dataOut","dataIn","qt","quantizationTable","v0","v1","v2","v3","v4","v5","v6","v7","sample","scanLine","line","JpegStreamReader","constructor","jfif","adobe","quantizationTables","huffmanTablesAC","huffmanTablesDC","resetFrames","frames","parse","readUint16","readDataBlock","subarray","prepareComponents","maxH","componentId","maxV","ceil","scanLines","blocksPerLineForMcu","blocksPerColumnForMcu","fileMarker","appData","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesLength","quantizationTablesEnd","quantizationTableSpec","tableData","extended","precision","componentsOrder","componentsCount","qId","quantizationIdx","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","selectorsCount","tableSpec","successiveApproximation","processed","getResult","cp","Object","keys","outComponents","scaleX","scaleY","out","oi","JpegDecoder","reader","JPEGTables","DeflateDecoder","PackbitsDecoder","dataView","DataView","header","getInt8","next","getUint8","getDecoder","Compression","copyNewSize","samplesPerPixel","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","cy","round","cx","lerp","resampleBilinear","rawY","yl","yh","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","GeoTIFFImage","sum","start","end","arrayForType","format","size","Int8Array","Int16Array","Float32Array","Float64Array","needsNormalization","normalizeArray","inBuffer","view","samplesToTransfer","outArray","bitMask","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","byteOffset","innerBitOffset","getUint16","raw","getUint32","littleEndian","cache","tiles","getFileDirectory","getGeoKeys","getWidth","getHeight","getSamplesPerPixel","SamplesPerPixel","getTileWidth","getTileHeight","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","getSampleByteSize","RangeError","getReaderForSample","sampleIndex","prototype","getInt16","getInt32","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","byteCount","fetch","request","sampleFormat","_readRaster","imageWindow","interleave","resampleMethod","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","si","promise","then","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","ymax","xmax","pixelOffset","call","windowCoordinate","Promise","all","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","numPixels","reject","apply","fill","Array","isArray","readRGB","enableAlpha","pi","PhotometricInterpretation","subOptions","ColorMap","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","string","xmlDom","substring","tagName","root","items","filter","child","item","Number","attributes","name","getGDALNoData","GDAL_NODATA","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","origin","resolution","x1","y1","x2","y2","DataView64","arrayBuffer","_dataView","getUint64","left","right","combined","isSafeInteger","getInt64","isNegative","carrying","getFloat16","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","covers","readUint8","readInt8","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","Pool","defaultPoolSize","navigator","hardwareConcurrency","worker","Worker","resolve","queue","err","destroy","terminate","CRLFCRLF","itemsToObject","fromEntries","obj","parseHeaders","text","split","kv","str","trim","parseContentType","rawContentType","type","rawParams","params","param","parseContentRange","rawContentRange","total","match","parseByteRanges","responseArrayBuffer","boundary","decoder","TextDecoder","startBoundary","endBoundary","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","fileSize","BaseSource","slices","fetchSlice","close","assign","target","chunk","iterable","results","lengthOfIterable","chunked","ci","endsWith","expectedEnding","actualEnding","forEach","func","invert","oldObj","newObj","range","times","numTimes","toArray","toArrayRecursively","headerValue","number","matches","unit","first","last","wait","milliseconds","setTimeout","zip","A","from","B","AbortError","captureStackTrace","CustomAggregateError","errors","message","AggregateError","Block","top","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockCache","LRUCache","blockRequests","Map","blockIdsToFetch","Set","cachedBlocks","missingBlockIds","current","blockId","has","set","get","add","fetchBlocks","cachedBlock","allSettled","some","status","retriedBlockRequests","rejected","reason","aborted","requiredBlocks","readSliceData","groups","groupBlocks","groupRequests","groupIndex","group","blockRequest","response","blockOffset","o","delete","clear","sortedBlockIds","sort","lastBlockId","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","delta","topDelta","blockInnerOffset","usedBlockLength","rangeInnerOffset","blockView","BaseResponse","ok","getHeader","headerName","getData","BaseClient","url","credentials","FetchResponse","FetchClient","XHRResponse","xhr","getResponseHeader","XHRClient","constructRequest","XMLHttpRequest","open","responseType","entries","setRequestHeader","onload","onerror","onabort","send","abort","addEventListener","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","urlMod","httpApi","protocol","http","https","on","Buffer","concat","RemoteSource","client","maxRanges","allowFullFile","_fileSize","fetchSlices","Range","join","byteRanges","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","ArrayBufferSource","makeBufferSource","FileReaderSource","file","blob","FileReader","event","readAsArrayBuffer","makeFileReaderSource","closeAsync","fd","openAsync","path","flags","mode","readAsync","args","bytesRead","FileSource","openRequest","alloc","makeFileSource","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","nextZero","oincr","readUshort","buff","readShort","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","String","fromCharCode","readFloat","fl32","readDouble","fl64","writeUshort","writeUint","writeASCII","charCodeAt","writeDouble","_writeIFD","bin","_offset","ifd","eoff","tag","typeName","typeNum","num","dlen","toff","encodeIfds","ifds","ifdo","noffs","encodeImage","prfx","img","convertToTids","error","metadataDefaults","writeGeotiff","numBands","flattenedValues","rowIndex","columnIndex","bandIndex","GeoKeyDirectory","NumberOfKeys","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","GeoAsciiParams","log","encodedMetadata","outputImage","DummyLogger","debug","info","time","timeEnd","LOGGER","setLogger","logger","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","geoKeyDirectory","location","getValues","dataSlice","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","options","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","ifdRequests","ghostValues","getSlice","fallbackSize","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","actualOffset","requestIFD","previousIfd","hasNext","getGhostValues","detectionString","heuristicAreaSize","valuesString","metadataSize","fullString","fromSource","headerData","BOM","TypeError","magicNumber","offsetByteSize","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","visited","relativeIndex","imageFile","ii","imageCounts","reduce","fromUrl","fromArrayBuffer","fromFile","fromBlob","fromUrls","mainUrl","overviewUrls","writeArrayBuffer"],"mappings":"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","file":"geotiff.js","sourceRoot":"../src","sourcesContent":["export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nexport default class RawDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\n\nconst dctZigZag = new Int32Array([\n  0,\n  1, 8,\n  16, 9, 2,\n  3, 10, 17, 24,\n  32, 25, 18, 11, 4,\n  5, 12, 19, 26, 33, 40,\n  48, 41, 34, 27, 20, 13, 6,\n  7, 14, 21, 28, 35, 42, 49, 56,\n  57, 50, 43, 36, 29, 22, 15,\n  23, 30, 37, 44, 51, 58,\n  59, 52, 45, 38, 31,\n  39, 46, 53, 60,\n  61, 54, 47,\n  55, 62,\n  63,\n]);\n\nconst dctCos1 = 4017; // cos(pi/16)\nconst dctSin1 = 799; // sin(pi/16)\nconst dctCos3 = 3406; // cos(3*pi/16)\nconst dctSin3 = 2276; // sin(3*pi/16)\nconst dctCos6 = 1567; // cos(6*pi/16)\nconst dctSin6 = 3784; // sin(6*pi/16)\nconst dctSqrt2 = 5793; // sqrt(2)\nconst dctSqrt1d2 = 2896;// sqrt(2) / 2\n\nfunction buildHuffmanTable(codeLengths, values) {\n  let k = 0;\n  const code = [];\n  let length = 16;\n  while (length > 0 && !codeLengths[length - 1]) {\n    --length;\n  }\n  code.push({ children: [], index: 0 });\n\n  let p = code[0];\n  let q;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < codeLengths[i]; j++) {\n      p = code.pop();\n      p.children[p.index] = values[k];\n      while (p.index > 0) {\n        p = code.pop();\n      }\n      p.index++;\n      code.push(p);\n      while (code.length <= i) {\n        code.push(q = { children: [], index: 0 });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n      k++;\n    }\n    if (i + 1 < length) {\n      // p here points to last code\n      code.push(q = { children: [], index: 0 });\n      p.children[p.index] = q.children;\n      p = q;\n    }\n  }\n  return code[0].children;\n}\n\nfunction decodeScan(data, initialOffset,\n  frame, components, resetInterval,\n  spectralStart, spectralEnd,\n  successivePrev, successive) {\n  const { mcusPerLine, progressive } = frame;\n\n  const startOffset = initialOffset;\n  let offset = initialOffset;\n  let bitsData = 0;\n  let bitsCount = 0;\n  function readBit() {\n    if (bitsCount > 0) {\n      bitsCount--;\n      return (bitsData >> bitsCount) & 1;\n    }\n    bitsData = data[offset++];\n    if (bitsData === 0xFF) {\n      const nextByte = data[offset++];\n      if (nextByte) {\n        throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);\n      }\n      // unstuff 0\n    }\n    bitsCount = 7;\n    return bitsData >>> 7;\n  }\n  function decodeHuffman(tree) {\n    let node = tree;\n    let bit;\n    while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign\n      node = node[bit];\n      if (typeof node === 'number') {\n        return node;\n      }\n      if (typeof node !== 'object') {\n        throw new Error('invalid huffman sequence');\n      }\n    }\n    return null;\n  }\n  function receive(initialLength) {\n    let length = initialLength;\n    let n = 0;\n    while (length > 0) {\n      const bit = readBit();\n      if (bit === null) {\n        return undefined;\n      }\n      n = (n << 1) | bit;\n      --length;\n    }\n    return n;\n  }\n  function receiveAndExtend(length) {\n    const n = receive(length);\n    if (n >= 1 << (length - 1)) {\n      return n;\n    }\n    return n + (-1 << length) + 1;\n  }\n  function decodeBaseline(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : receiveAndExtend(t);\n    component.pred += diff;\n    zz[0] = component.pred;\n    let k = 1;\n    while (k < 64) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n  }\n  function decodeDCFirst(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n    component.pred += diff;\n    zz[0] = component.pred;\n  }\n  function decodeDCSuccessive(component, zz) {\n    zz[0] |= readBit() << successive;\n  }\n  let eobrun = 0;\n  function decodeACFirst(component, zz) {\n    if (eobrun > 0) {\n      eobrun--;\n      return;\n    }\n    let k = spectralStart;\n    const e = spectralEnd;\n    while (k <= e) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          eobrun = receive(r) + (1 << r) - 1;\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n  }\n  let successiveACState = 0;\n  let successiveACNextValue;\n  function decodeACSuccessive(component, zz) {\n    let k = spectralStart;\n    const e = spectralEnd;\n    let r = 0;\n    while (k <= e) {\n      const z = dctZigZag[k];\n      const direction = zz[z] < 0 ? -1 : 1;\n      switch (successiveACState) {\n        case 0: { // initial state\n          const rs = decodeHuffman(component.huffmanTableAC);\n          const s = rs & 15;\n          r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1) {\n              throw new Error('invalid ACn encoding');\n            }\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue; // eslint-disable-line no-continue\n        }\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            r--;\n            if (r === 0) {\n              successiveACState = successiveACState === 2 ? 3 : 0;\n            }\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          }\n          break;\n        default:\n          break;\n      }\n      k++;\n    }\n    if (successiveACState === 4) {\n      eobrun--;\n      if (eobrun === 0) {\n        successiveACState = 0;\n      }\n    }\n  }\n  function decodeMcu(component, decodeFunction, mcu, row, col) {\n    const mcuRow = (mcu / mcusPerLine) | 0;\n    const mcuCol = mcu % mcusPerLine;\n    const blockRow = (mcuRow * component.v) + row;\n    const blockCol = (mcuCol * component.h) + col;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n  function decodeBlock(component, decodeFunction, mcu) {\n    const blockRow = (mcu / component.blocksPerLine) | 0;\n    const blockCol = mcu % component.blocksPerLine;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n\n  const componentsLength = components.length;\n  let component;\n  let i;\n  let j;\n  let k;\n  let n;\n  let decodeFn;\n  if (progressive) {\n    if (spectralStart === 0) {\n      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n    } else {\n      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n  } else {\n    decodeFn = decodeBaseline;\n  }\n\n  let mcu = 0;\n  let marker;\n  let mcuExpected;\n  if (componentsLength === 1) {\n    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n  } else {\n    mcuExpected = mcusPerLine * frame.mcusPerColumn;\n  }\n\n  const usedResetInterval = resetInterval || mcuExpected;\n\n  while (mcu < mcuExpected) {\n    // reset interval stuff\n    for (i = 0; i < componentsLength; i++) {\n      components[i].pred = 0;\n    }\n    eobrun = 0;\n\n    if (componentsLength === 1) {\n      component = components[0];\n      for (n = 0; n < usedResetInterval; n++) {\n        decodeBlock(component, decodeFn, mcu);\n        mcu++;\n      }\n    } else {\n      for (n = 0; n < usedResetInterval; n++) {\n        for (i = 0; i < componentsLength; i++) {\n          component = components[i];\n          const { h, v } = component;\n          for (j = 0; j < v; j++) {\n            for (k = 0; k < h; k++) {\n              decodeMcu(component, decodeFn, mcu, j, k);\n            }\n          }\n        }\n        mcu++;\n\n        // If we've reached our expected MCU's, stop decoding\n        if (mcu === mcuExpected) {\n          break;\n        }\n      }\n    }\n\n    // find marker\n    bitsCount = 0;\n    marker = (data[offset] << 8) | data[offset + 1];\n    if (marker < 0xFF00) {\n      throw new Error('marker was not found');\n    }\n\n    if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n\n  return offset - startOffset;\n}\n\nfunction buildComponentData(frame, component) {\n  const lines = [];\n  const { blocksPerLine, blocksPerColumn } = component;\n  const samplesPerLine = blocksPerLine << 3;\n  const R = new Int32Array(64);\n  const r = new Uint8Array(64);\n\n  // A port of poppler's IDCT method which in turn is taken from:\n  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n  //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n  //   988-991.\n  function quantizeAndInverse(zz, dataOut, dataIn) {\n    const qt = component.quantizationTable;\n    let v0;\n    let v1;\n    let v2;\n    let v3;\n    let v4;\n    let v5;\n    let v6;\n    let v7;\n    let t;\n    const p = dataIn;\n    let i;\n\n    // dequant\n    for (i = 0; i < 64; i++) {\n      p[i] = zz[i] * qt[i];\n    }\n\n    // inverse DCT on rows\n    for (i = 0; i < 8; ++i) {\n      const row = 8 * i;\n\n      // check for all-zero AC coefficients\n      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0\n        && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0\n        && p[7 + row] === 0) {\n        t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;\n        p[0 + row] = t;\n        p[1 + row] = t;\n        p[2 + row] = t;\n        p[3 + row] = t;\n        p[4 + row] = t;\n        p[5 + row] = t;\n        p[6 + row] = t;\n        p[7 + row] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;\n      v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;\n      v2 = p[2 + row];\n      v3 = p[6 + row];\n      v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;\n      v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;\n      v5 = p[3 + row] << 4;\n      v6 = p[5 + row] << 4;\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[0 + row] = v0 + v7;\n      p[7 + row] = v0 - v7;\n      p[1 + row] = v1 + v6;\n      p[6 + row] = v1 - v6;\n      p[2 + row] = v2 + v5;\n      p[5 + row] = v2 - v5;\n      p[3 + row] = v3 + v4;\n      p[4 + row] = v3 - v4;\n    }\n\n    // inverse DCT on columns\n    for (i = 0; i < 8; ++i) {\n      const col = i;\n\n      // check for all-zero AC coefficients\n      if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0\n        && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0\n        && p[(7 * 8) + col] === 0) {\n        t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;\n        p[(0 * 8) + col] = t;\n        p[(1 * 8) + col] = t;\n        p[(2 * 8) + col] = t;\n        p[(3 * 8) + col] = t;\n        p[(4 * 8) + col] = t;\n        p[(5 * 8) + col] = t;\n        p[(6 * 8) + col] = t;\n        p[(7 * 8) + col] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;\n      v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;\n      v2 = p[(2 * 8) + col];\n      v3 = p[(6 * 8) + col];\n      v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;\n      v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;\n      v5 = p[(3 * 8) + col];\n      v6 = p[(5 * 8) + col];\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[(0 * 8) + col] = v0 + v7;\n      p[(7 * 8) + col] = v0 - v7;\n      p[(1 * 8) + col] = v1 + v6;\n      p[(6 * 8) + col] = v1 - v6;\n      p[(2 * 8) + col] = v2 + v5;\n      p[(5 * 8) + col] = v2 - v5;\n      p[(3 * 8) + col] = v3 + v4;\n      p[(4 * 8) + col] = v3 - v4;\n    }\n\n    // convert to 8-bit integers\n    for (i = 0; i < 64; ++i) {\n      const sample = 128 + ((p[i] + 8) >> 4);\n      if (sample < 0) {\n        dataOut[i] = 0;\n      } else if (sample > 0XFF) {\n        dataOut[i] = 0xFF;\n      } else {\n        dataOut[i] = sample;\n      }\n    }\n  }\n\n  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n    const scanLine = blockRow << 3;\n    for (let i = 0; i < 8; i++) {\n      lines.push(new Uint8Array(samplesPerLine));\n    }\n    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n      let offset = 0;\n      const sample = blockCol << 3;\n      for (let j = 0; j < 8; j++) {\n        const line = lines[scanLine + j];\n        for (let i = 0; i < 8; i++) {\n          line[sample + i] = r[offset++];\n        }\n      }\n    }\n  }\n  return lines;\n}\n\nclass JpegStreamReader {\n  constructor() {\n    this.jfif = null;\n    this.adobe = null;\n\n    this.quantizationTables = [];\n    this.huffmanTablesAC = [];\n    this.huffmanTablesDC = [];\n    this.resetFrames();\n  }\n\n  resetFrames() {\n    this.frames = [];\n  }\n\n  parse(data) {\n    let offset = 0;\n    // const { length } = data;\n    function readUint16() {\n      const value = (data[offset] << 8) | data[offset + 1];\n      offset += 2;\n      return value;\n    }\n    function readDataBlock() {\n      const length = readUint16();\n      const array = data.subarray(offset, offset + length - 2);\n      offset += array.length;\n      return array;\n    }\n    function prepareComponents(frame) {\n      let maxH = 0;\n      let maxV = 0;\n      let component;\n      let componentId;\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          if (maxH < component.h) {\n            maxH = component.h;\n          }\n          if (maxV < component.v) {\n            maxV = component.v;\n          }\n        }\n      }\n      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n          const blocksPerLineForMcu = mcusPerLine * component.h;\n          const blocksPerColumnForMcu = mcusPerColumn * component.v;\n          const blocks = [];\n          for (let i = 0; i < blocksPerColumnForMcu; i++) {\n            const row = [];\n            for (let j = 0; j < blocksPerLineForMcu; j++) {\n              row.push(new Int32Array(64));\n            }\n            blocks.push(row);\n          }\n          component.blocksPerLine = blocksPerLine;\n          component.blocksPerColumn = blocksPerColumn;\n          component.blocks = blocks;\n        }\n      }\n      frame.maxH = maxH;\n      frame.maxV = maxV;\n      frame.mcusPerLine = mcusPerLine;\n      frame.mcusPerColumn = mcusPerColumn;\n    }\n\n    let fileMarker = readUint16();\n    if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\n      throw new Error('SOI not found');\n    }\n\n    fileMarker = readUint16();\n    while (fileMarker !== 0xFFD9) { // EOI (End of image)\n      switch (fileMarker) {\n        case 0xFF00: break;\n        case 0xFFE0: // APP0 (Application Specific)\n        case 0xFFE1: // APP1\n        case 0xFFE2: // APP2\n        case 0xFFE3: // APP3\n        case 0xFFE4: // APP4\n        case 0xFFE5: // APP5\n        case 0xFFE6: // APP6\n        case 0xFFE7: // APP7\n        case 0xFFE8: // APP8\n        case 0xFFE9: // APP9\n        case 0xFFEA: // APP10\n        case 0xFFEB: // APP11\n        case 0xFFEC: // APP12\n        case 0xFFED: // APP13\n        case 0xFFEE: // APP14\n        case 0xFFEF: // APP15\n        case 0xFFFE: { // COM (Comment)\n          const appData = readDataBlock();\n\n          if (fileMarker === 0xFFE0) {\n            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49\n              && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n              this.jfif = {\n                version: { major: appData[5], minor: appData[6] },\n                densityUnits: appData[7],\n                xDensity: (appData[8] << 8) | appData[9],\n                yDensity: (appData[10] << 8) | appData[11],\n                thumbWidth: appData[12],\n                thumbHeight: appData[13],\n                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),\n              };\n            }\n          }\n          // TODO APP1 - Exif\n          if (fileMarker === 0xFFEE) {\n            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F\n              && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n              this.adobe = {\n                version: appData[6],\n                flags0: (appData[7] << 8) | appData[8],\n                flags1: (appData[9] << 8) | appData[10],\n                transformCode: appData[11],\n              };\n            }\n          }\n          break;\n        }\n\n        case 0xFFDB: { // DQT (Define Quantization Tables)\n          const quantizationTablesLength = readUint16();\n          const quantizationTablesEnd = quantizationTablesLength + offset - 2;\n          while (offset < quantizationTablesEnd) {\n            const quantizationTableSpec = data[offset++];\n            const tableData = new Int32Array(64);\n            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = data[offset++];\n              }\n            } else if ((quantizationTableSpec >> 4) === 1) { // 16 bit\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = readUint16();\n              }\n            } else {\n              throw new Error('DQT: invalid table spec');\n            }\n            this.quantizationTables[quantizationTableSpec & 15] = tableData;\n          }\n          break;\n        }\n\n        case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n        case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n        case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)\n          readUint16(); // skip data length\n          const frame = {\n            extended: (fileMarker === 0xFFC1),\n            progressive: (fileMarker === 0xFFC2),\n            precision: data[offset++],\n            scanLines: readUint16(),\n            samplesPerLine: readUint16(),\n            components: {},\n            componentsOrder: [],\n          };\n\n          const componentsCount = data[offset++];\n          let componentId;\n          // let maxH = 0;\n          // let maxV = 0;\n          for (let i = 0; i < componentsCount; i++) {\n            componentId = data[offset];\n            const h = data[offset + 1] >> 4;\n            const v = data[offset + 1] & 15;\n            const qId = data[offset + 2];\n            frame.componentsOrder.push(componentId);\n            frame.components[componentId] = {\n              h,\n              v,\n              quantizationIdx: qId,\n            };\n            offset += 3;\n          }\n          prepareComponents(frame);\n          this.frames.push(frame);\n          break;\n        }\n\n        case 0xFFC4: { // DHT (Define Huffman Tables)\n          const huffmanLength = readUint16();\n          for (let i = 2; i < huffmanLength;) {\n            const huffmanTableSpec = data[offset++];\n            const codeLengths = new Uint8Array(16);\n            let codeLengthSum = 0;\n            for (let j = 0; j < 16; j++, offset++) {\n              codeLengths[j] = data[offset];\n              codeLengthSum += codeLengths[j];\n            }\n            const huffmanValues = new Uint8Array(codeLengthSum);\n            for (let j = 0; j < codeLengthSum; j++, offset++) {\n              huffmanValues[j] = data[offset];\n            }\n            i += 17 + codeLengthSum;\n\n            if ((huffmanTableSpec >> 4) === 0) {\n              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            } else {\n              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            }\n          }\n          break;\n        }\n\n        case 0xFFDD: // DRI (Define Restart Interval)\n          readUint16(); // skip data length\n          this.resetInterval = readUint16();\n          break;\n\n        case 0xFFDA: { // SOS (Start of Scan)\n          readUint16(); // skip length\n          const selectorsCount = data[offset++];\n          const components = [];\n          const frame = this.frames[0];\n          for (let i = 0; i < selectorsCount; i++) {\n            const component = frame.components[data[offset++]];\n            const tableSpec = data[offset++];\n            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\n            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\n            components.push(component);\n          }\n          const spectralStart = data[offset++];\n          const spectralEnd = data[offset++];\n          const successiveApproximation = data[offset++];\n          const processed = decodeScan(data, offset,\n            frame, components, this.resetInterval,\n            spectralStart, spectralEnd,\n            successiveApproximation >> 4, successiveApproximation & 15);\n          offset += processed;\n          break;\n        }\n\n        case 0xFFFF: // Fill bytes\n          if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n            offset--;\n          }\n          break;\n\n        default:\n          if (data[offset - 3] === 0xFF\n            && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n            // could be incorrect encoding -- last 0xFF byte of the previous\n            // block was eaten by the encoder\n            offset -= 3;\n            break;\n          }\n          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);\n      }\n      fileMarker = readUint16();\n    }\n  }\n\n  getResult() {\n    const { frames } = this;\n    if (this.frames.length === 0) {\n      throw new Error('no frames were decoded');\n    } else if (this.frames.length > 1) {\n      console.warn('more than one frame is not supported');\n    }\n\n    // set each frame's components quantization table\n    for (let i = 0; i < this.frames.length; i++) {\n      const cp = this.frames[i].components;\n      for (const j of Object.keys(cp)) {\n        cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\n        delete cp[j].quantizationIdx;\n      }\n    }\n\n    const frame = frames[0];\n    const { components, componentsOrder } = frame;\n    const outComponents = [];\n    const width = frame.samplesPerLine;\n    const height = frame.scanLines;\n\n    for (let i = 0; i < componentsOrder.length; i++) {\n      const component = components[componentsOrder[i]];\n      outComponents.push({\n        lines: buildComponentData(frame, component),\n        scaleX: component.h / frame.maxH,\n        scaleY: component.v / frame.maxV,\n      });\n    }\n\n    const out = new Uint8Array(width * height * outComponents.length);\n    let oi = 0;\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        for (let i = 0; i < outComponents.length; ++i) {\n          const component = outComponents[i];\n          out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];\n          ++oi;\n        }\n      }\n    }\n    return out;\n  }\n}\n\nexport default class JpegDecoder extends BaseDecoder {\n  constructor(fileDirectory) {\n    super();\n    this.reader = new JpegStreamReader();\n    if (fileDirectory.JPEGTables) {\n      this.reader.parse(fileDirectory.JPEGTables);\n    }\n  }\n\n  decodeBlock(buffer) {\n    this.reader.resetFrames();\n    this.reader.parse(new Uint8Array(buffer));\n    return this.reader.getResult().buffer;\n  }\n}\n","import { inflate } from 'pako/lib/inflate';\nimport BaseDecoder from './basedecoder';\n\nexport default class DeflateDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return inflate(new Uint8Array(buffer)).buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nexport default class PackbitsDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    const dataView = new DataView(buffer);\n    const out = [];\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      let header = dataView.getInt8(i);\n      if (header < 0) {\n        const next = dataView.getUint8(i + 1);\n        header = -header;\n        for (let j = 0; j <= header; ++j) {\n          out.push(next);\n        }\n        i += 1;\n      } else {\n        for (let j = 0; j <= header; ++j) {\n          out.push(dataView.getUint8(i + j + 1));\n        }\n        i += header + 1;\n      }\n    }\n    return new Uint8Array(out).buffer;\n  }\n}\n","import RawDecoder from './raw';\nimport LZWDecoder from './lzw';\nimport JpegDecoder from './jpeg';\nimport DeflateDecoder from './deflate';\nimport PackbitsDecoder from './packbits';\n\nexport function getDecoder(fileDirectory) {\n  switch (fileDirectory.Compression) {\n    case undefined:\n    case 1: // no compression\n      return new RawDecoder();\n    case 5: // LZW\n      return new LZWDecoder();\n    case 6: // JPEG\n      throw new Error('old style JPEG compression is not supported.');\n    case 7: // JPEG\n      return new JpegDecoder(fileDirectory);\n    case 8: // Deflate as recognized by Adobe\n    case 32946: // Deflate GDAL default\n      return new DeflateDecoder();\n    case 32773: // packbits\n      return new PackbitsDecoder();\n    default:\n      throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/* eslint max-len: [\"error\", { \"code\": 120 }] */\n\nimport { getFloat16 } from '@petamoriken/float16';\nimport txml from 'txml';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb';\nimport { getDecoder } from './compression';\nimport { resample, resampleInterleaved } from './resample';\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(this.getWidth() / this.getTileWidth()),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(this.getHeight() / this.getTileHeight()),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          promises.push(promise);\n          promise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]));\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]));\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is\n   *                                 not the same as the images, resampling will be\n   *                                 performed.\n   * @param {number} [options.height] The desired height of the output. When the width\n   *                                  is not the same as the images, resampling will\n   *                                  be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {number|number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When\n   *                                              multiple samples are requested, an\n   *                                              array of fill values can be passed.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {bool} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise.<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, pool = null, width, height, resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave: true,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {Number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n    const xmlDom = txml(string.substring(0, string.length - 1));\n\n    if (!xmlDom[0].tagName) {\n      throw new Error('Failed to parse GDAL metadata XML.');\n    }\n\n    const root = xmlDom[0];\n    if (root.tagName !== 'GDALMetadata') {\n      throw new Error('Unexpected GDAL metadata XML tag.');\n    }\n\n    let items = root.children\n      .filter((child) => child.tagName === 'Item');\n\n    if (sample !== null) {\n      items = items.filter((item) => Number(item.attributes.sample) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[item.attributes.name] = item.children[0];\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {Number} or null\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + 2 ** 32 * right;\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`\n        );\n      }\n      return combined;\n    }\n    combined = 2 ** 32 * left + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative =\n      (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * 256 ** i;\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + 2 ** 32 * right;\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`,\n        );\n      }\n      return combined;\n    }\n    combined = 2 ** 32 * left + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`,\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative =\n      (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80) >\n      0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i)\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * 256 ** i;\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","import { Pool as tPool, spawn, Worker, Transfer } from 'threads';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : null;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} size The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {Worker} worker The decoder worker, loaded and initialised. Enables\n   *                        loading the worker using worker-loader(or others) externally\n   *                        when using this library as a webpack dependency.\n   */\n  constructor(size = defaultPoolSize, worker = new Worker('./decoder.worker.js')) {\n    this.pool = tPool(() => spawn(worker), size);\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise.<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    return new Promise((resolve, reject) => {\n      this.pool.queue(async (decode) => {\n        try {\n          const data = await decode(fileDirectory, Transfer(buffer));\n          resolve(data);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  destroy() {\n    this.pool.terminate(true);\n  }\n}\n\nexport default Pool;\n","\nconst CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map(line => {\n      const kv = line.split(':').map(str => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length)\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error(\"Could not find initial boundary\");\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return await Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource';\nimport { AbortError, AggregateError, wait, zip } from '../utils';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new LRUCache({ max: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const cachedBlocks = new Map();\n    const blockRequests = new Map();\n    const missingBlockIds = new Set();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      // chunk the current slice into blocks\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        // check if the block is cached, being requested or still missing\n        const blockId = Math.floor(current / this.blockSize);\n\n        if (this.blockCache.has(blockId)) {\n          cachedBlocks.set(blockId, this.blockCache.get(blockId));\n        } else if (this.blockRequests.has(blockId)) {\n          blockRequests.set(blockId, this.blockRequests.get(blockId));\n        } else if (this.blockIdsToFetch.has(blockId)) {\n          missingBlockIds.add(blockId);\n        } else {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.add(blockId);\n        }\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    for (const blockId of missingBlockIds) {\n      const block = this.blockRequests.get(blockId);\n      const cachedBlock = this.blockCache.get(blockId);\n\n      if (block) {\n        blockRequests.set(blockId, block);\n      } else if (cachedBlock) {\n        cachedBlocks.set(blockId, cachedBlock);\n      } else {\n        throw new Error(`Block ${blockId} is not in the block requests`);\n      }\n    }\n\n    // actually await all pending requests\n    let results = await Promise.allSettled(blockRequests.values());\n\n    // perform retries if a block was interrupted by a previous signal\n    if (results.some((result) => result.status === 'rejected')) {\n      const retriedBlockRequests = new Set();\n      for (const [blockId, result] of zip(blockRequests.keys(), results)) {\n        const { rejected, reason } = result;\n        if (rejected) {\n          // push some blocks back to the to-fetch list if they were\n          // aborted, but only when a different signal was used\n          if (reason.name === 'AbortError' && reason.signal !== signal) {\n            this.blockIdsToFetch.add(blockId);\n            retriedBlockRequests.add(blockId);\n          }\n        }\n      }\n\n      // start the retry of some blocks if required\n      if (this.blockIdsToFetch.length > 0) {\n        this.fetchBlocks(signal);\n        for (const blockId of retriedBlockRequests) {\n          const block = this.blockRequests.get(blockId);\n          if (!block) {\n            throw new Error(`Block ${blockId} is not in the block requests`);\n          }\n          blockRequests.set(blockId, block);\n        }\n        results = await Promise.allSettled(Array.from(blockRequests.values()));\n      }\n    }\n\n    // throw an error (either abort error or AggregateError if no abort was done)\n    if (results.some((result) => result.status === 'rejected')) {\n      if (signal && signal.aborted) {\n        throw new AbortError('Request was aborted');\n      }\n      throw new AggregateError(\n        results.filter((result) => result.status === 'rejected').map((result) => result.reason),\n        'Request failed',\n      );\n    }\n\n    // extract the actual block responses\n    const values = results.map((result) => result.value);\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n    for (const [blockId, block] of cachedBlocks) {\n      requiredBlocks.set(blockId, block);\n    }\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          const blockRequest = (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n              );\n              this.blockCache.set(blockId, block);\n              return block;\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n              }\n              throw err;\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })();\n          this.blockRequests.set(blockId, blockRequest);\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      const top = slice.offset + slice.length;\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {object} [options]\n   */\n  async request({ headers, credentials, signal } = {}) {\n    throw new Error(`request is not implemented`);\n  }\n}\n\n","import { BaseClient, BaseResponse } from './base';\n\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  async request({ headers, credentials, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base';\nimport { AbortError } from '../../utils';\n\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base';\nimport { AbortError } from '../../utils';\n\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolve) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolve(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils';\nimport { BaseSource } from './basesource';\nimport { BlockedSource } from './blockedsource';\n\nimport { FetchClient } from './client/fetch';\nimport { XHRClient } from './client/xhr';\nimport { HttpClient } from './client/http';\n\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return await Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource';\nimport { AbortError } from '../utils';\n\n\nclass ArrayBufferSource extends BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nexport function makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n","import { BaseSource } from './basesource';\n\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","import { read, open, close } from 'fs';\nimport { BaseSource } from './basesource';\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nexport function makeFileSource(path) {\n  return new FileSource(path);\n}\n","/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals';\nimport { assign, endsWith, forEach, invert, times } from './utils';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (typeof val === 'undefined') {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['XPosition', 0],\n  ['YPosition', 0],\n  ['ResolutionUnit', 1], // Code 1 for actual pixel count or 2 for pixels per inch.\n  ['ExtraSamples', 0], // should this be an array??\n  ['GeoAsciiParams', 'WGS 84\\u0000'],\n  ['ModelTiepoint', [0, 0, 0, -180, 90, 0]], // raster fits whole globe\n  ['GTModelTypeGeoKey', 2],\n  ['GTRasterTypeGeoKey', 1],\n  ['GeographicTypeGeoKey', 4326],\n  ['GeogCitationGeoKey', 'WGS 84'],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'PhotometricInterpretation',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n","\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nexport function setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nexport function debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nexport function log(...args) {\n  return LOGGER.log(...args);\n}\n\nexport function info(...args) {\n  return LOGGER.info(...args);\n}\n\nexport function warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nexport function error(...args) {\n  return LOGGER.error(...args);\n}\n\nexport function time(...args) {\n  return LOGGER.time(...args);\n}\n\nexport function timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n","import GeoTIFFImage from './geotiffimage';\nimport DataView64 from './dataview64';\nimport DataSlice from './dataslice';\nimport Pool from './pool';\n\nimport { makeRemoteSource } from './source/remote';\nimport { makeBufferSource } from './source/arraybuffer';\nimport { makeFileReaderSource } from './source/filereader';\nimport { makeFileSource } from './source/file';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals';\nimport { writeGeotiff } from './geotiffwriter';\nimport * as globals from './globals';\nimport * as rgb from './rgb';\nimport { getDecoder } from './compression';\nimport { setLogger } from './logging';\n\nexport { globals };\nexport { rgb };\nexport { getDecoder };\nexport { setLogger };\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.bbox=whole image] the subset to read data from in\n   *                                           geographical coordinates.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {Number} [options.width] The desired width of the output. When the width is not the\n   *                                 same as the images, resampling will be performed.\n   * @param {Number} [options.height] The desired height of the output. When the width is not the\n   *                                  same as the images, resampling will be performed.\n   * @param {String} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @param {Number|Number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When multiple\n   *                                              samples are requested, an array of fill values\n   *                                              can be passed.\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {Source} source The datasource to read from.\n   * @param {Boolean} littleEndian Whether the image uses little endian.\n   * @param {Boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {Number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {Object} [options] further options.\n   * @param {Boolean} [options.cache=false] whether or not decoded tiles shall be cached.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {ImageFileDirectory} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff ?\n      dataSlice.readUint64(offset) :\n      dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff ?\n        dataSlice.readUint64(i + 4) :\n        dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 &&\n        !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Object} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter(line => line.length > 0)\n        .map(line => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {source~Source} source The source of data to parse from.\n   * @param {object} options Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport async function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\n"]}